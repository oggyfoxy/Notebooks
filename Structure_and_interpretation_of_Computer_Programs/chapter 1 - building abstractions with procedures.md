
home: [[SICP]]
---

## 1.1 The Elements of Programming

the general form of a procedure deﬁnition is
(define (⟨name⟩ ⟨formal parameters⟩)
⟨ body⟩)

**substitution model**
- evaluation works by subsituting expressions until you hit primitive values

a procedure is a function that does not return any value. 

	imperative vs declarative knowledge: in maths with declarative (what    is) descriptions, in CS with imperative (how to) descriptions 

each procedure should accomplish an identifiable task, using to define other procedures. we can see procedures as black-box abstractions.

we shouldnt know how a procedure is implemented to be able to use it.

variables can be bound or free. 

block structure is used to break up large programs into structural pieces. 


normal order: fully expand then reduce (the left-most functions are evaluated first)
applicative order: eval arguments then reduce (inner-most functions are evaluted first)

https://sookocheff.com/post/fp/evaluating-lambda-expressions/#applicative-order-evaluation-1


##### exercices ch 1.1

exercice 1.1

- 10 
- 12
- 8
- 3
- 6
- 19
- false
- 4
- 16
- 6
- 16

exercice 1.2

```
(/ (+ 5 4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
  (* 3
     (- 6 2)
     (- 2 7)))
```

exercice 1.3

```
(define (square x)
  (* x x))

(define (sum-of-squares x y)
 (+ (square x) (square y)))

(define (sum x y z)
  (if (and (< x y) (< x z)) (+ (sum-of-squares y z))
  (if (and (< y x) (< y z)) (+ (sum-of-squares x z))
  (sum-of-squares x y))))
```

(sum 2 3 4)

exercice 1.4
if b > 0, op sign is +
else, op sign is - (which creates a plus)


## 1.2 procedures and the processes they generate

### exercises 
ex 1.9

both are recursive but the second one is more space efficient

first procedure
```
(+ 4 5)
→ (inc (+ (dec 4) 5))
→ (inc (+ 3 5))
→ (inc (inc (+ (dec 3) 5)))
→ (inc (inc (+ 2 5)))
→ (inc (inc (inc (+ (dec 2) 5))))
→ (inc (inc (inc (+ 1 5))))
→ (inc (inc (inc (inc (+ (dec 1) 5)))))
→ (inc (inc (inc (inc (+ 0 5)))))
→ (inc (inc (inc (inc 5))))
→ (inc (inc (inc 6)))
→ (inc (inc 7))
→ (inc 8)
→ 9
```

second procedure
```
(+ 4 5)
→ (+ (dec 4) (inc 5))
→ (+ 3 6)
→ (+ (dec 3) (inc 6))
→ (+ 2 7)
→ (+ (dec 2) (inc 7))
→ (+ 1 8)
→ (+ (dec 1) (inc 8))
→ (+ 0 9)
→ 9
```


ex 1.10

(A 1 10) = 1024
(A 2 4) = 65535
(A 3 3) = 65535

(f n) -> 0n
(g n) -> n
(h n) -> 2n
(k n) -> 5n^2


ex 1.11

recursive:

```
(define (F n)
  (if (< n 3)
      n
      (+ (F (- n 1))
         (* 2 (F(- n 2)))
         (* 3 (F(- n 3))))))
```

iterative:

```
(define (func-iter n)
  (define (iter i n-1 n-2 n-3)
    (if (> i n)
        n-1
        (iter (+ i 1)
             (+ n-1 (* 2 n-2) (* 3 n-3))
             n-1
             n-2)))
  (if (< n 3)
      n
      (iter 3 2 1 0))) ; f(2) = 2, f(1) = 1; f(0) = 0

(func-iter 4
```


ex 1.12
```

	`(define (pascal r k)`
	  `(if (or (= k 0) (= k r))`
	        `1`
	        `(+ (pascal (- r 1) (- k 1))`
	           `(pascal (- r 1) k))))`
	
	
	`(pascal 7 3)
```

#### 1.2.1 linear recursion and iteration

In order to become experts, we need to learn how to visualize the processes generated by various types of procedures.
- we will see common patterns of process evolution

example: factorial procedure
- recursive process vs iterative process. we can also see this as a linear recursive process vs linear iterative process

#### 1.2.2 tree recursion

pattern: tree recursion
example: fibonacci sequence

![[Pasted image 20250205201642.png]]


#### 1.2.3 orders of growth

ex 1.14

(count-change 11) returns 4
order of growth of the space: 
number of steps:

ex 1.16

```
(define (fast-ext b n)
  (iter-ext 1 b n))

(define (iter-ext a b n)
  (cond ((= n 0) a)
   ((even? n) (iter-ext a (* b b) (/ n 2))
   (else (iter-ext (* a b) b (- n 1)))))

```

iterative approach, has a state variable a (using it to store the result). 
time complexity : O(log n)
space complexity: O(1)

whereas on the recursive approach, the space complexity is proportional (in this case: O(log n))

ex 1.17

```
#lang sicp


(define (double x) (+ x x))
(define (half x) (/ x 2))
(define (even? n) (= (remainder n 2) 0))


(define (fast-mult a b)
  (cond ((= b 0) 0)
      ((even? b) (double (fast-mult a (half b))))
      (else (+ a (fast-mult a (- b 1))))))


(fast-mult 3 5)
```

has a similar pattern as fast-exp but with multiplication this time.


ex 1.18

```
(define (double x) (+ x x))
(define (half x) (/ x 2))
(define (even? n) (= (remainder n 2) 0))


(define (fast-mult a b)
  (define (iter acc a b)
    (cond ((= b 0) acc)
          ((even? b) (iter acc (double a) (half b)))
          (else (iter (+ acc a) a (- b 1)))))
  (iter 0 a b))


(fast-mult 3 5)
```

used nested defines to create an iterative procedure with an accumulator

ex 1.19

```
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q)) ; compute p′
                   (+ (* q q) (* 2 p q)) ; compute q′
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(fib 100)
```

ex 1.20

```
#lang sicp

  
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))



; normal order, fully expand then reduce.
gcd(206 40)
(if (= 40 0) ...)
(gcd 40 (remainder 206 40))
(if (= (remainder 206 40) 0) ...)
(if (= 6 0) ... )

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
(if (= (remainder 40 (remainder 206 40)) 0) ...)
(if (= (remainder 40 6) 0) ...)
(if (= 4 0) ...)

(gcd  (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
...

; applicative order
(gcd 206 40)

(if (= 40 0) ...)
(gcd 40 (remainder 206 40))
(gcd 40 6)

(if (= 6 0) ...)
(gcd 6 (remainder 40 6))
(gcd 6 4)

(if (= 4 0) ...)
(gcd 4 (remainder 6 4))
(gcd 4 2)

...

```


this highlights clearly the problem of normal-order evaluation in the computation of gcd, resulting nested loops with the remainders.


skipping mathematical (Fermat) exercises


## 1.3 Formulating Abstractions with Higher-Order Procedures



ex 1.29
```
(define (cube x)
  (* x x x))

(define (sum term a next b)
(if (> a b)
    0
    (+ (term a)
       (sum term (next a) next b))))

(define (inc x)
  (+ x 1))

(define (integral f a b n)
  (define h
    (/ (- b a) n))
  (define (term k)
    (cond
       ((or (= k 0) (= k n)) (f (+ a (* k h)))) ; first and last
       ((odd? k) (* 4 (f (+ a (* k h))))) ; odd
       (else (* 2 (f (+ a (* k h))))))) ; even
    
  (* (/ h 3) (sum term 0 inc n)))


(integral cube 0 1 100)
```

this procedure was recursive 


ex 1.30

```
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))
  (iter a 0))

```
dont forget to store result when doing iterative counting.



----
chapter 1 of the [[SICP]] book. 
next up -> [[chapter 2 - building abstractions with data]]

